webpackJsonp([1],[,,,,,,,,,function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function r(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}function i(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)}var a=(t(0),t(12)),s=t(18),c=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),g=function n(e,t,o){null===e&&(e=Function.prototype);var r=Object.getOwnPropertyDescriptor(e,t);if(void 0===r){var i=Object.getPrototypeOf(e);return null===i?void 0:n(i,t,o)}if("value"in r)return r.value;var a=r.get;if(void 0!==a)return a.call(o)},v=function(n){function e(){o(this,e);var n=r(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return n.camera.position.z=1,n.particles=new s.a,n.scene.add(n.particles.view),n.createBrandTag(),n.animate(),n}return i(e,n),c(e,[{key:"createBrandTag",value:function(){var n=document.createElement("a");n.href="http://www.colordodge.com",n.innerHTML="<div id='brandTag'>Colordodge</div>",document.body.appendChild(n),window.addEventListener("keydown",function(n){if("72"==n.keyCode){var e=document.getElementById("brandTag");"hidden"==e.style.visibility?e.style.visibility="visible":e.style.visibility="hidden"}},!1)}},{key:"animate",value:function(){this.particles.update(),g(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"animate",this).call(this)}}]),e}(a.a);e.a=v},function(n,e,t){var o=t(25);"string"==typeof o&&(o=[[n.i,o,""]]);var r={};r.transform=void 0;t(98)(o,r);o.locals&&(n.exports=o.locals)},function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=t(10);t.n(o);new(t(9).a)},function(n,e,t){"use strict";(function(n){function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}var r=(t(0),t(76)),i=(t.n(r),t(77)),a=(t.n(i),t(27)),s=t.n(a),c=t(74),g=t.n(c),v=t(32),f=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),x=function(){function e(){o(this,e);var t=window.innerWidth,r=window.innerHeight;this._camera=new n.OrthographicCamera(t/-2,t/2,r/2,r/-2,-5e3,5e3),window.camera=this._camera,this._scene=new n.Scene,this._renderer=new n.WebGLRenderer({antialias:!1,alpha:!1,depthBuffer:!1,stencilBuffer:!1}),this._renderer.setSize(window.innerWidth,window.innerHeight),window.renderer=this._renderer,document.body.appendChild(this._renderer.domElement),this.composer=new v.a(this._renderer),this.composer.addPass(new v.b(this._scene,this._camera));var i=new v.c;i.intensity=2,i.kernalSize=10,i.distinction=.01,i.renderToScreen=!0,this.composer.addPass(i),this.clock=new n.Clock,this.ambientLight=new n.AmbientLight(16777215,.3),this._scene.add(this.ambientLight),this.directionalLight=new n.DirectionalLight(16777215,1.6),this.directionalLight.position.set(-1,2,1),this._scene.add(this.directionalLight),this._controls=new n.OrbitControls(this._camera,this._renderer.domElement),this._controls.enableDamping=!0,this._controls.dampingFactor=.1,this._controls.rotateSpeed=.1,this._controls.autoRotate=!1,this._controls.autoRotateSpeed=.2,this._controls.zoomSpeed=.1,this._controls.enableKeys=!1,window.controls=this._controls,window.gui=new s.a.GUI,window.gui.close();var a=gui.addFolder("Bloom");a.add(i,"intensity",0,10),a.add(i,"distinction",0,1),this.stats=new g.a,this.stats.setMode(0),this.stats.domElement.style.position="absolute",this.stats.domElement.style.left="10px",this.stats.domElement.style.top="0px",window.addEventListener("resize",this.onWindowResize.bind(this),!1)}return f(e,[{key:"onWindowResize",value:function(){this._camera.aspect=window.innerWidth/window.innerHeight,this._camera.updateProjectionMatrix(),this._renderer.setSize(window.innerWidth,window.innerHeight)}},{key:"animate",value:function(n){this.stats.begin(),requestAnimationFrame(this.animate.bind(this)),this._controls.update(),this.composer.render(this.clock.getDelta()),this.stats.end()}},{key:"renderer",get:function(){return this._renderer}},{key:"camera",get:function(){return this._camera}},{key:"scene",get:function(){return this._scene}}]),e}();e.a=x}).call(e,t(0))},function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}var r=t(0),i=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),a=function(){function n(){o(this,n),this.canvas=document.createElement("canvas"),this.canvas.id="gradientCanvas",this.canvas.width=256,this.canvas.height=256,this.canvas.style.width="200px",this.canvas.style.height="200px",this.width=this.canvas.width,this.height=this.canvas.height,this.subCanvas=document.createElement("canvas"),this.subCanvas.id="gradientCanvasSub",this.subCanvas.width=256,this.subCanvas.height=256,this.ctx=this.subCanvas.getContext("2d"),document.body.appendChild(this.canvas),this.toggleCanvasDisplay(!1),this.transitionRatio=0}return i(n,[{key:"update",value:function(){this.transitionRatio<1&&(this.transitionRatio+=.005,this.transitionRatio>=1&&(this.transitionRatio=1),this.drawSubToMain())}},{key:"generateTexture",value:function(){this.transitionRatio=0,this.waterLevel=0;var n=this.randRange(0,1);this.baseColor=(new r.Color).setHSL(n,1,.5),this.colorAngle=this.randRange(.1,.4),this.circleSize=100,this.fillBaseColor();for(var e=0;e<150;e++)this.randomGradientCircle()}},{key:"drawSubToMain",value:function(){var n=this.canvas.getContext("2d"),e=this.height*this.transitionRatio;n.drawImage(this.subCanvas,0,0,this.width,e,0,0,this.width,e),this.texture=new r.CanvasTexture(this.canvas)}},{key:"toggleCanvasDisplay",value:function(n){this.canvas.style.display=n?"block":"none"}},{key:"randomGradientStrip",value:function(){var n=(this.randRange(0,this.width),this.randRange(0,this.height),this.randRange(0,this.width),this.randRange(0,this.height),this.ctx.createLinearGradient(0,0,0,this.height)),e=this.randRange(.2,.8),t=this.randomColor();n.addColorStop(e-.2,"rgba("+t.r+", "+t.g+", "+t.b+", 0.0)"),n.addColorStop(e,"rgba("+t.r+", "+t.g+", "+t.b+", 0.8)"),n.addColorStop(e+.2,"rgba("+t.r+", "+t.g+", "+t.b+", 0.0)"),this.ctx.fillStyle=n,this.ctx.fillRect(0,0,this.width,this.height)}},{key:"randomGradientCircle",value:function(){var n=this.randRange(0,this.width),e=this.randRange(0,this.height),t=this.randRange(5,40),o=n,r=e,i=t,a=this.ctx.createRadialGradient(n,e,0,o,r,i),s=this.randomColor();a.addColorStop(0,"rgba("+s.r+", "+s.g+", "+s.b+", 1.0)"),a.addColorStop(.5,"rgba("+s.r+", "+s.g+", "+s.b+", 1.0)"),a.addColorStop(1,"rgba("+s.r+", "+s.g+", "+s.b+", 0.0)"),this.ctx.fillStyle=a,this.ctx.fillRect(0,0,this.width,this.height)}},{key:"fillBaseColor",value:function(){this.ctx.fillStyle=this.toCanvasColor(new r.Color(this.baseColor)),this.ctx.fillRect(0,0,this.width,this.height)}},{key:"randomColor",value:function(){return this.randomColorQuad()}},{key:"randomColorTriad",value:function(){var n=this.baseColor.clone(),e=0,t=this.randRange(0,1);e=t<.33?0+this.randRange(-.03,.03):t<.66?this.colorAngle+this.randRange(-.03,.03):-this.colorAngle+this.randRange(-.03,.03);var o=n.getHSL();return o.h+=e,o.s=this.randRange(.5,1),o.l=this.randRange(.3,.5),n.setHSL(o.h,o.s,o.l),{r:Math.round(255*n.r),g:Math.round(255*n.g),b:Math.round(255*n.b)}}},{key:"randomColorQuad",value:function(){var n=this.baseColor.clone(),e=0,t=this.randRange(0,1);e=t<.25?0+this.randRange(-.01,.01):t<.5?this.colorAngle+this.randRange(-.01,.01):t<.75?.5+this.randRange(-.01,.01):.5+this.colorAngle+this.randRange(-.01,.01);var o=n.getHSL();return o.h+=e,o.s=this.randRange(.7,1),o.l=this.randRange(.5,.7),n.setHSL(o.h,o.s,o.l),{r:Math.round(255*n.r),g:Math.round(255*n.g),b:Math.round(255*n.b)}}},{key:"toCanvasColor",value:function(n){return"rgba("+Math.round(255*n.r)+", "+Math.round(255*n.g)+", "+Math.round(255*n.b)+", 1.0)"}},{key:"randRange",value:function(n,e){var t=e-n;return n+Math.random()*t}},{key:"mix",value:function(n,e,t){return n+(e-n)*t}}]),n}();e.a=a},function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function r(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}function i(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)}var a=t(0),s=t(83),c=t.n(s),g=t(82),v=t.n(g),f=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),x=function(n){function e(n){o(this,e);var t=r(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,{uniforms:{time:{type:"f",value:0},seed:{type:"f",value:1e3*Math.random()},flowRate:{type:"f",value:1},noiseMag:{type:"f",value:1},res1:{type:"f",value:2.1},res2:{type:"f",value:40.11},resolution:{type:"f",value:n.res},aspect:{type:"f",value:window.innerWidth/window.innerHeight},velTexture:{type:"t",value:new a.Texture},posTexture:{type:"t",value:new a.Texture}},vertexShader:c.a,fragmentShader:v.a,transparent:!0,depthWrite:!1}));return t.res=n.res,t.flowRate=.5,t.noiseMag=.25,t.res1=4,t.res2=20,t.noiseSpeed=.5,t.folder=window.gui.addFolder("2 : Curl"),t.folder.add(t,"flowRate",0,1).step(.01),t.folder.add(t,"noiseMag",0,1).step(.01),t.folder.add(t,"noiseSpeed",0,1).step(.01),t.folder.add(t,"res1",0,20).step(.01),t.folder.add(t,"res2",0,100).step(.01),t}return i(e,n),f(e,[{key:"update",value:function(n){this.uniforms.time.value+=.002*this.noiseSpeed,this.uniforms.resolution.value=this.res,this.uniforms.flowRate.value=this.flowRate,this.uniforms.noiseMag.value=this.noiseMag,this.uniforms.res1.value=this.res1,this.uniforms.res2.value=this.res2,this.uniforms.aspect.value=window.innerWidth/window.innerHeight,this.uniforms.velTexture.value=n.velTexture,this.uniforms.posTexture.value=n.posTexture}}]),e}(a.ShaderMaterial);e.a=x},function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function r(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}function i(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)}var a=t(0),s=t(85),c=t.n(s),g=t(84),v=t.n(g),f=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),x=function(n){function e(n){o(this,e);var t=r(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,{uniforms:{time:{type:"f",value:0},seed:{type:"f",value:1e3*Math.random()},flowRate:{type:"f",value:1},respawn:{type:"f",value:.5},res1:{type:"f",value:2.1},res2:{type:"f",value:40.11},resolution:{type:"f",value:n.res},aspect:{type:"f",value:window.innerWidth/window.innerHeight},velTexture:{type:"t",value:new a.Texture},posTexture:{type:"t",value:new a.Texture}},vertexShader:c.a,fragmentShader:v.a,transparent:!0,depthWrite:!1}));return t.res=n.res,t.flowRate=.3,t.respawn=.3,t.res1=2.1,t.res2=40.11,t.folder=window.gui.addFolder("1 : Flow"),t.folder.add(t,"flowRate",0,1).step(.01),t.folder.add(t,"respawn",0,1),t.folder.add(t,"res1",0,5),t.folder.add(t,"res2",5,100),t}return i(e,n),f(e,[{key:"update",value:function(n){this.uniforms.time.value+=.001,this.uniforms.resolution.value=this.res,this.uniforms.flowRate.value=this.flowRate,this.uniforms.respawn.value=this.respawn,this.uniforms.res1.value=this.res1,this.uniforms.res2.value=this.res2,this.uniforms.aspect.value=window.innerWidth/window.innerHeight,this.uniforms.velTexture.value=n.velTexture,this.uniforms.posTexture.value=n.posTexture}}]),e}(a.ShaderMaterial);e.a=x},function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function r(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}function i(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)}var a=t(0),s=t(87),c=t.n(s),g=t(86),v=t.n(g),f=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),x=function(n){function e(n){o(this,e);var t=r(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,{uniforms:{time:{type:"f",value:0},seed:{type:"f",value:1e3*Math.random()},noiseMag:{type:"f",value:1},noiseRes:{type:"f",value:2.1},resolution:{type:"f",value:n.res},aspect:{type:"f",value:window.innerWidth/window.innerHeight},tNoise:{type:"f",value:1e3*Math.random()},velTexture:{type:"t",value:new a.Texture},posTexture:{type:"t",value:new a.Texture}},vertexShader:c.a,fragmentShader:v.a,transparent:!0,depthWrite:!1}));return t.res=n.res,t.noiseMag=.2,t.noiseSpeed=.5,t.noiseRes=1.5,t.folder=window.gui.addFolder("4 : Marble"),t.folder.add(t,"noiseMag",0,1).step(.01),t.folder.add(t,"noiseSpeed",0,1).step(.01),t.folder.add(t,"noiseRes",0,3).step(.01),t}return i(e,n),f(e,[{key:"update",value:function(n){this.uniforms.time.value+=.001,this.uniforms.tNoise.value+=.002*this.noiseSpeed,this.uniforms.noiseRes.value=this.noiseRes,this.uniforms.resolution.value=this.res,this.uniforms.noiseMag.value=this.noiseMag,this.uniforms.aspect.value=window.innerWidth/window.innerHeight,this.uniforms.velTexture.value=n.velTexture,this.uniforms.posTexture.value=n.posTexture}}]),e}(a.ShaderMaterial);e.a=x},function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function r(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}function i(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)}var a=t(0),s=t(89),c=t.n(s),g=t(88),v=t.n(g),f=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),x=function(n){function e(n){o(this,e);var t=r(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,{uniforms:{time:{type:"f",value:1e3*Math.random()},seed:{type:"f",value:1e3*Math.random()},flowRate:{type:"f",value:1},res1:{type:"f",value:2.1},res2:{type:"f",value:40.11},resolution:{type:"f",value:n.res},aspect:{type:"f",value:window.innerWidth/window.innerHeight},velTexture:{type:"t",value:new a.Texture},posTexture:{type:"t",value:new a.Texture}},vertexShader:c.a,fragmentShader:v.a,transparent:!0,depthWrite:!1}));return t.res=n.res,t.flowRate=.2,t.res1=2.1,t.res2=40.11,t.speed=.3,t.folder=window.gui.addFolder("3 : Osc"),t.folder.add(t,"speed",0,1),t}return i(e,n),f(e,[{key:"update",value:function(n){this.uniforms.time.value+=.003*this.speed,this.uniforms.resolution.value=this.res,this.uniforms.flowRate.value=this.flowRate,this.uniforms.res1.value=this.res1,this.uniforms.res2.value=this.res2,this.uniforms.aspect.value=window.innerWidth/window.innerHeight,this.uniforms.velTexture.value=n.velTexture,this.uniforms.posTexture.value=n.posTexture}}]),e}(a.ShaderMaterial);e.a=x},function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}var r=t(0),i=t(79),a=t.n(i),s=t(78),c=t.n(s),g=t(20),v=t(23),f=t(13),x=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),l=function(){function n(){var e=this;o(this,n),this.view=new r.Object3D,this.size=512,this.partSize=1,this.hueNoiseRes=1,this.hueNoiseSpeed=.1,this.hueSpeed=.2,this.hueRange=.8,this.hueZMod=2,this.autoRandomize=!0,this.autoRandCount=0,this.autoRandTime=30,this.autoRandMax=60*this.autoRandTime,this.particleFolder=window.gui.addFolder("Particle"),this.particleFolder.add(this,"partSize",.5,10).step(.5),this.colorFolder=window.gui.addFolder("Color"),this.colorFolder.add(this,"hueNoiseRes",0,2),this.colorFolder.add(this,"hueNoiseSpeed",0,.6),this.colorFolder.add(this,"hueZMod",1,10),this.colorFolder.add(this,"randomizeColors"),this.colorFolder.add(this,"autoRandomize"),this.colorFolder.add(this,"autoRandTime",3,300).step(1).onChange(function(n){e.autoRandMax=60*n}),this.colorGradient=new f.a,this.colorGradient.generateTexture(),this.posTexture=new g.a({res:this.size}),this.velTexture=new v.a({res:this.size}),this.geo=new r.PlaneBufferGeometry(30,30,this.size,this.size),this.mat=new r.ShaderMaterial({uniforms:{time:{type:"f",value:1e3*Math.random()},width:{type:"f",value:window.innerWidth},height:{type:"f",value:window.innerHeight},partSize:{type:"f",value:this.partSize},hueNoiseRes:{type:"f",value:this.hueNoiseRes},hueNoiseSpeed:{type:"f",value:this.hueNoiseSpeed},hueSpeed:{type:"f",value:this.hueSpeed},hueRange:{type:"f",value:this.hueRange},hueZMod:{type:"f",value:this.hueZMod},posTexture:{type:"t",value:new r.Texture},velTexture:{type:"t",value:new r.Texture},colorGradient:{type:"t",value:this.colorGradient.texture}},vertexShader:a.a,fragmentShader:c.a,transparent:!1}),this.plane=new r.Points(this.geo,this.mat),this.view.add(this.plane)}return x(n,[{key:"randomizeColors",value:function(){this.colorGradient.generateTexture()}},{key:"update",value:function(){this.colorGradient.update(),this.autoRandomize&&++this.autoRandCount>this.autoRandMax&&(this.autoRandCount=0,this.randomizeColors()),this.velTexture.posTexture=this.posTexture.texture,this.velTexture.update(),this.posTexture.velTexture=this.velTexture.texture,this.posTexture.update(),this.mat.uniforms.time.value+=.01,this.mat.uniforms.width.value=window.innerWidth,this.mat.uniforms.height.value=window.innerHeight,this.mat.uniforms.partSize.value=this.partSize,this.mat.uniforms.hueNoiseRes.value=this.hueNoiseRes,this.mat.uniforms.hueNoiseSpeed.value=this.hueNoiseSpeed,this.mat.uniforms.hueSpeed.value=this.hueSpeed,this.mat.uniforms.hueRange.value=this.hueRange,this.mat.uniforms.hueZMod.value=this.hueZMod,this.mat.uniforms.posTexture.value=this.posTexture.texture,this.mat.uniforms.velTexture.value=this.velTexture.texture,this.mat.uniforms.colorGradient.value=this.colorGradient.texture}}]),n}();e.a=l},function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function r(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}function i(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)}var a=t(0),s=t(91),c=t.n(s),g=t(90),v=t.n(g),f=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),x=function(n){function e(n){o(this,e);var t=r(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,{uniforms:{time:{type:"f",value:1e3*Math.random()},seed:{type:"f",value:1e3*Math.random()},flowRate:{type:"f",value:1},res1:{type:"f",value:2.1},res2:{type:"f",value:40.11},curveMag:{type:"f",value:.5},pulseMag:{type:"f",value:.5},curveMod:{type:"f",value:.5},resolution:{type:"f",value:n.res},aspect:{type:"f",value:window.innerWidth/window.innerHeight},velTexture:{type:"t",value:new a.Texture},posTexture:{type:"t",value:new a.Texture}},vertexShader:c.a,fragmentShader:v.a,transparent:!0,depthWrite:!1}));return t.res=n.res,t.flowRate=1,t.res1=3,t.res2=6,t.curveMag=.5,t.curveMod=.5,t.pulseMag=.5,t.speed=.3,t.time=0,t.lastSign=1,t.folder=window.gui.addFolder("6 : Polar"),t.folder.add(t,"speed",0,1).step(.01),t.folder.add(t,"curveMag",-2,2).step(.01).listen(),t.folder.add(t,"pulseMag",0,1).step(.01).listen(),t.folder.add(t,"res1",1,20).step(1).listen(),t.folder.add(t,"res2",1,20).step(1).listen(),t}return i(e,n),f(e,[{key:"update",value:function(n){this.time+=.003,this.curveMag=1*Math.sin(this.time);var e=this.curveMag>0?1:-1;if(e!=this.lastSign){this.lastSign=e;this.res1=Math.ceil(6*Math.random()),this.res2=Math.ceil(6*Math.random())}this.pulseMag=1*Math.sin(.5*this.time+38.256),this.uniforms.time.value+=.03*this.speed,this.uniforms.resolution.value=this.res,this.uniforms.flowRate.value=this.flowRate,this.uniforms.res1.value=this.res1,this.uniforms.res2.value=this.res2,this.uniforms.curveMag.value=this.curveMag,this.uniforms.curveMod.value=this.curveMod,this.uniforms.pulseMag.value=this.pulseMag,this.uniforms.aspect.value=window.innerWidth/window.innerHeight,this.uniforms.velTexture.value=n.velTexture,this.uniforms.posTexture.value=n.posTexture}}]),e}(a.ShaderMaterial);e.a=x},function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}var r=t(0),i=t(81),a=t.n(i),s=t(80),c=t.n(s),g=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),v=function(){function n(e){var t=this;o(this,n),this.res=e.res,this.texture=new r.Texture,this.velTexture=new r.Texture,this.setup(),this.resetPos=!0,document.addEventListener("keydown",function(n){32==n.keyCode&&(console.log("space"),t.resetPos=!0)})}return g(n,[{key:"setup",value:function(){var n=this.res;this.renderTextureA=new r.WebGLRenderTarget(n,n,{minFilter:r.NearestFilter,magFilter:r.NearestFilter,format:r.RGBAFormat,type:r.FloatType,depthBuffer:!1,stencilBuffer:!1}),this.renderTextureB=new r.WebGLRenderTarget(n,n,{minFilter:r.NearestFilter,magFilter:r.NearestFilter,format:r.RGBAFormat,type:r.FloatType,depthBuffer:!1,stencilBuffer:!1}),this.textureCamera=new r.OrthographicCamera(-n/2,n/2,n/2,-n/2,-100,100),this.textureCamera.position.z=10,this.mat=new r.ShaderMaterial({uniforms:{time:{type:"f",value:0},seed:{type:"f",value:1e3*Math.random()},resetPos:{type:"f",value:1},resolution:{type:"f",value:this.res},aspect:{type:"f",value:window.innerWidth/window.innerHeight},posTexture:{type:"t",value:this.renderTextureA.texture},velTexture:{type:"t",value:this.velTexture.texture}},vertexShader:a.a,fragmentShader:c.a,transparent:!0,depthWrite:!1}),this.textureScene=new r.Scene,this.geo=new r.PlaneGeometry(n,n),this.plane=new r.Mesh(this.geo,this.mat),this.plane.position.z=-10,this.textureScene.add(this.plane)}},{key:"render",value:function(){this.resetPos?(this.resetPos=!1,this.mat.uniforms.resetPos.value=1):this.mat.uniforms.resetPos.value=0,this.mat.uniforms.time.value+=.001,this.mat.uniforms.resolution.value=this.res,this.mat.uniforms.aspect.value=window.innerWidth/window.innerHeight,this.mat.uniforms.posTexture.value=this.renderTextureA.texture,this.mat.uniforms.velTexture.value=this.velTexture,window.renderer.render(this.textureScene,this.textureCamera,this.renderTextureB,!0);var n=this.renderTextureA;this.renderTextureA=this.renderTextureB,this.renderTextureB=n,this.texture=this.renderTextureA.texture}},{key:"update",value:function(){this.render()}}]),n}();e.a=v},function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function r(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}function i(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)}var a=t(0),s=t(93),c=t.n(s),g=t(92),v=t.n(g),f=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),x=function(n){function e(n){o(this,e);var t=r(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,{uniforms:{time:{type:"f",value:1e3*Math.random()},seed:{type:"f",value:1e3*Math.random()},flowRate:{type:"f",value:1},res1:{type:"f",value:2.1},res2:{type:"f",value:40.11},resolution:{type:"f",value:n.res},aspect:{type:"f",value:window.innerWidth/window.innerHeight},velTexture:{type:"t",value:new a.Texture},posTexture:{type:"t",value:new a.Texture}},vertexShader:c.a,fragmentShader:v.a,transparent:!0,depthWrite:!1}));return t.res=n.res,t.flowRate=1,t.res1=2.1,t.res2=40.11,t.speed=.3,t.folder=window.gui.addFolder("7 : Ripple"),t.folder.add(t,"speed",0,1),t}return i(e,n),f(e,[{key:"update",value:function(n){this.uniforms.time.value+=.02*this.speed,this.uniforms.resolution.value=this.res,this.uniforms.flowRate.value=this.flowRate,this.uniforms.res1.value=this.res1,this.uniforms.res2.value=this.res2,this.uniforms.aspect.value=window.innerWidth/window.innerHeight,this.uniforms.velTexture.value=n.velTexture,this.uniforms.posTexture.value=n.posTexture}}]),e}(a.ShaderMaterial);e.a=x},function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function r(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}function i(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)}var a=t(0),s=t(95),c=t.n(s),g=t(94),v=t.n(g),f=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),x=function(n){function e(n){o(this,e);var t=r(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,{uniforms:{time:{type:"f",value:1e3*Math.random()},seed:{type:"f",value:1e3*Math.random()},flowRate:{type:"f",value:1},res1:{type:"f",value:2.1},res2:{type:"f",value:40.11},sizeMod:{type:"f",value:1},resolution:{type:"f",value:n.res},aspect:{type:"f",value:window.innerWidth/window.innerHeight},velTexture:{type:"t",value:new a.Texture},posTexture:{type:"t",value:new a.Texture}},vertexShader:c.a,fragmentShader:v.a,transparent:!0,depthWrite:!1}));return t.res=n.res,t.flowRate=1,t.res1=2.1,t.res2=40.11,t.speed=.5,t.sizeMod=1,t.folder=window.gui.addFolder("8 : Spyro"),t.folder.add(t,"speed",0,1),t.folder.add(t,"sizeMod",.5,3),t}return i(e,n),f(e,[{key:"update",value:function(n){this.uniforms.time.value+=.01*this.speed,this.uniforms.resolution.value=this.res,this.uniforms.flowRate.value=this.flowRate,this.uniforms.res1.value=this.res1,this.uniforms.res2.value=this.res2,this.uniforms.sizeMod.value=this.sizeMod,this.uniforms.aspect.value=window.innerWidth/window.innerHeight,this.uniforms.velTexture.value=n.velTexture,this.uniforms.posTexture.value=n.posTexture}}]),e}(a.ShaderMaterial);e.a=x},function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}var r=t(0),i=t(15),a=t(14),s=t(17),c=t(16),g=t(24),v=t(19),f=t(21),x=t(22),l=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),y=function(){function n(e){o(this,n),this.res=e.res,this.setup()}return l(n,[{key:"setup",value:function(){var n=this,e=this.res;this.renderTextureA=new r.WebGLRenderTarget(e,e,{minFilter:r.NearestFilter,magFilter:r.NearestFilter,format:r.RGBAFormat,type:r.FloatType,depthBuffer:!1,stencilBuffer:!1}),this.renderTextureB=new r.WebGLRenderTarget(e,e,{minFilter:r.NearestFilter,magFilter:r.NearestFilter,format:r.RGBAFormat,type:r.FloatType,depthBuffer:!1,stencilBuffer:!1}),this.textureCamera=new r.OrthographicCamera(-e/2,e/2,e/2,-e/2,-100,100),this.textureCamera.position.z=10,this.flowMat=new i.a({res:e}),this.curlMat=new a.a({res:e}),this.oscMat=new s.a({res:e}),this.marbleMat=new c.a({res:e}),this.waveMat=new g.a({res:e}),this.polarMat=new v.a({res:e}),this.rippleMat=new f.a({res:e}),this.tempMat=new x.a({res:e}),this.mat=this.flowMat,this.modeIndex=0,this.textureScene=new r.Scene,this.geo=new r.PlaneGeometry(e,e),this.plane=new r.Mesh(this.geo,this.mat),this.plane.position.z=-10,this.textureScene.add(this.plane),this.keyWasPressed=!1,this.keycode=0,document.addEventListener("keydown",function(e){n.keyWasPressed=!0,n.keyCode=e.keyCode}),window.renderer.domElement.addEventListener("mousedown",function(e){n.mouseDoesSwitchMode&&n.selectRandomMode()}),this.autoSwitch=!1,this.autoSwitchTime=3,this.autoSwitchMaxTime=60*this.autoSwitchTime,this.autoSwitchCounter=0;var t=window.gui.addFolder("Auto Switch");t.add(this,"autoSwitch"),t.add(this,"autoSwitchTime",3,300).step(1).onChange(function(e){n.autoSwitchMaxTime=60*e}),this.mouseBehavior="Switch Mode",this.mouseDoesSwitchMode=!0,window.controls.enabled=!1,window.gui.add(this,"mouseBehavior",["Switch Mode","Rotate Camera"]).onChange(function(e){"Switch Mode"==e?(n.mouseDoesSwitchMode=!0,window.controls.enabled=!1):(n.mouseDoesSwitchMode=!1,window.controls.enabled=!0)})}},{key:"render",value:function(){this.mat.update({velTexture:this.renderTextureA.texture,posTexture:this.posTexture}),window.renderer.render(this.textureScene,this.textureCamera,this.renderTextureB,!0);var n=this.renderTextureA;this.renderTextureA=this.renderTextureB,this.renderTextureB=n,this.texture=this.renderTextureA.texture,this.autoSwitch&&++this.autoSwitchCounter>this.autoSwitchMaxTime&&(this.autoSwitchCounter=0,this.selectRandomMode()),this.keyWasPressed&&(this.keyWasPressed=!1,49==this.keyCode&&(this.mat=this.flowMat),50==this.keyCode&&(this.mat=this.curlMat),51==this.keyCode&&(this.mat=this.oscMat),52==this.keyCode&&(this.mat=this.marbleMat),53==this.keyCode&&(this.mat=this.waveMat),54==this.keyCode&&(this.mat=this.polarMat),55==this.keyCode&&(this.mat=this.rippleMat),56==this.keyCode&&(this.mat=this.tempMat),this.plane.material=this.mat)}},{key:"selectRandomMode",value:function(){for(var n=[this.flowMat,this.curlMat,this.oscMat,this.marbleMat,this.waveMat,this.polarMat,this.rippleMat,this.tempMat],e=Math.floor(Math.random()*n.length);e==this.modeIndex;)e=Math.floor(Math.random()*n.length);this.modeIndex=e,this.mat=n[this.modeIndex],this.plane.material=this.mat}},{key:"update",value:function(){this.render()}}]),n}();e.a=y},function(n,e,t){"use strict";function o(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function r(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}function i(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)}var a=t(0),s=t(97),c=t.n(s),g=t(96),v=t.n(g),f=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),x=function(n){function e(n){o(this,e);var t=r(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,{uniforms:{time:{type:"f",value:1e3*Math.random()},seed:{type:"f",value:1e3*Math.random()},flowRate:{type:"f",value:1},res1:{type:"f",value:2.1},res2:{type:"f",value:40.11},resolution:{type:"f",value:n.res},aspect:{type:"f",value:window.innerWidth/window.innerHeight},velTexture:{type:"t",value:new a.Texture},posTexture:{type:"t",value:new a.Texture}},vertexShader:c.a,fragmentShader:v.a,transparent:!0,depthWrite:!1}));return t.res=n.res,t.flowRate=.5,t.res1=2.1,t.res2=40.11,t.speed=.3,t.folder=window.gui.addFolder("5 : Wave"),t.folder.add(t,"speed",0,1),t}return i(e,n),f(e,[{key:"update",value:function(n){this.uniforms.time.value+=.05*this.speed,this.uniforms.resolution.value=this.res,this.uniforms.flowRate.value=this.flowRate,this.uniforms.res1.value=this.res1,this.uniforms.res2.value=this.res2,this.uniforms.aspect.value=window.innerWidth/window.innerHeight,this.uniforms.velTexture.value=n.velTexture,this.uniforms.posTexture.value=n.posTexture}}]),e}(a.ShaderMaterial);e.a=x},function(n,e,t){e=n.exports=t(26)(void 0),e.push([n.i,'body {\n    width: 100%;\n    height: 100%;\n    background-color: #000;\n    color: #fff;\n    margin: 0px;\n    padding: 0;\n    overflow: hidden;\n    font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;\n}\n\n#brandTag\n{\n\tposition: fixed;\n\tdisplay: block;\n\ttop: 0px;\n\tleft: 30px;\n\tcolor: white;\n\tbackground-color: rgba(0, 0, 0, 0.8);\n\tz-index: 1000;\n\ttext-align: center;\n\tpadding: 12px 12px 12px 12px;\n\tfont-size: 18px;\n\tfont-family: "Helvetica", sans-serif;\n\ttransition-property: color, background-color, padding;\n\ttransition-duration: 0.3s;\n}\n\n#brandTag:hover\n{\n\tcolor: black;\n\tbackground-color: white;\n\tpadding: 24px 12px 12px 12px;\n}\n\n#gradientCanvas {\n  position: absolute;\n  z-index: 1000;\n  bottom: 0px;\n  right: 0px;\n}\n\n#nebulaeCanvas {\n  position: absolute;\n  z-index: 1000;\n  bottom: 0px;\n  left: 0px;\n}\n\n/* Position the button VR on the bottom of the page. */\n#ui {\n    position: absolute;\n    bottom: 10px;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    text-align: center;\n    font-family: \'Karla\', sans-serif;\n    z-index: 1;\n}\n\na#magic-window {\n    display: block;\n    color: white;\n    margin-top: 1em;\n}\n\n#loadingBarHolder {\n  position: absolute;\n\n  left: 0px;\n  right: 0px;\n  top: 0px;\n  bottom: 0px;\n  margin: auto;\n\n  width: 25%;\n  height: 10%;\n\n  border: 1px solid #222222;\n  padding: 20px;\n  padding-top: 30px;\n  background-color: #111111;\n  z-index: 2000;\n}\n\n#loadingBarBase {\n  width: 100%;\n  height: 50%;\n  margin-top: 10px;\n  background-color: #222222;\n}\n\n#loadingBar {\n  width: 50%;\n  height: 100%;\n  background-color: #444444;\n}\n',""])},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(n,e){n.exports="precision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec3 vColor;\n\nuniform float time;\n\nvoid main() {\n\tgl_FragColor = vec4(vColor, 1.0);\n}\n"},function(n,e){n.exports='vec3 hsv2rgb_2_0(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\n//\n// GLSL textureless classic 4D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_1_1(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_2(vec4 x)\n{\n  return mod289_1_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_3(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 fade_1_4(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_1_5(vec4 P)\n{\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod289_1_1(Pi0);\n  Pi1 = mod289_1_1(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute_1_2(permute_1_2(ix) + iy);\n  vec4 ixy0 = permute_1_2(ixy + iz0);\n  vec4 ixy1 = permute_1_2(ixy + iz1);\n  vec4 ixy00 = permute_1_2(ixy0 + iw0);\n  vec4 ixy01 = permute_1_2(ixy0 + iw1);\n  vec4 ixy10 = permute_1_2(ixy1 + iw0);\n  vec4 ixy11 = permute_1_2(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt_1_3(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt_1_3(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt_1_3(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt_1_3(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade_1_4(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\n\n\n\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\n\nvarying vec3 vColor;\n\nuniform float time;\nuniform float width;\nuniform float height;\nuniform float partSize;\nuniform float hueNoiseRes;\nuniform float hueNoiseSpeed;\nuniform float hueSpeed;\nuniform float hueRange;\nuniform float hueZMod;\nuniform sampler2D posTexture;\nuniform sampler2D velTexture;\nuniform sampler2D colorGradient;\n\nfloat rand(vec2 co){\n\t\tfloat r = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\t// r = (r - 0.5) * 2.0;\n    return r;\n}\n\nfloat perlin4d(vec4 pos) {\n\tfloat n = cnoise_1_5(vec4(pos));\n\treturn (n + 1.0) * 0.5;\n\t// return pow(abs(n), 0.5);\n}\n\nvoid main() {\n\n\tgl_PointSize = partSize;\n\n\tvec3 newPos = texture2D(posTexture, vec2(uv.x, uv.y)).xyz;\n\tvec3 vel = texture2D(velTexture, vec2(uv.x, uv.y)).xyz;\n\n\t/////////////////////////////////\n\n\t// float depth = (newPos.z + 1.0) * 0.5;\n\t// float v = 1.0 - (1.0-depth) * depthShading;\n\t// float s = 1.0;\n\t//\n\t// // float h = newPos.y*0.6 - time*0.03;\n\t// vec3 hVec = newPos;\n\t// hVec.z *= hueZMod;\n\t// // hVec.x = 0.0;\n\t// // hVec.y = 0.0;\n\t// float h = perlin4d(vec4(hVec * hueNoiseRes, time*hueNoiseSpeed))*hueRange + fract(time*hueSpeed);\n\t// float hOffset = rand(uv + 13.9754);\n\t// if (hOffset < bigChance) {\n\t// \th += bigHueMod;\n\t// \tv = 1.0;\n\t// \ts = 0.1;\n\t// \tgl_PointSize = partSize*bigSizeMod;\n\t// \t// s = 0.5;\n\t// }\n\t// vColor = hsv2rgb(vec3(h, s, v));\n\n\t////////////////////////////////////\n\n\tfloat depth = (newPos.z + 1.0) * 0.5;\n\tfloat v = 1.0 - (1.0-depth);\n\tfloat s = 1.0;\n\n\tvec3 cPos = newPos;\n\tcPos.z *= hueZMod;\n\tfloat n = perlin4d(vec4(cPos * hueNoiseRes, time*hueNoiseSpeed));\n\t// n = fract(n*3.0);\n\n\tn = (n - 0.5) * 1.3 + 0.5;\n\n\tfloat cx = sin(time * 0.1);\n\tcx = (cx+1.0) * 0.5;\n\tvColor = texture2D(colorGradient, vec2(cx, n)).xyz;\n\n\n\t////////////////////////////////////////\n\n\t// center the particles on the screen and enlarge\n\tnewPos.x = (newPos.x - 0.0) * height;\n\tnewPos.y = (newPos.y - 0.0) * height;\n\tnewPos.z = (newPos.z - 0.0) * height;\n\n\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);\n}\n'},function(n,e){n.exports="\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nuniform float time;\nuniform float resetPos;\nuniform float resolution;\nuniform float aspect;\nuniform float seed;\nuniform sampler2D posTexture;\nuniform sampler2D velTexture;\n\nvoid main() {\n\n\tvec2 pos = vUv;\n\tvec2 absPos = (gl_FragCoord.xy / resolution) - 0.5;\n\tabsPos.x *= aspect;\n\n\n\tvec3 currentVel = texture2D(velTexture, pos).xyz;\n\tvec3 currentPos = texture2D(posTexture, pos).xyz;\n\tvec3 newPos = currentPos;\n\n\tnewPos += currentVel;\n\n\n\tif (resetPos == 1.0) {\n\t\t// newPos = vec3(sin(time));\n\t\t// newPos = vec3(pos, 0.5);\n\t\tnewPos = vec3(absPos, 0.0);\n\t}\n\n\n\tgl_FragColor = vec4(newPos, 1.0);\n}\n"},function(n,e){n.exports="\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"},function(n,e){n.exports='//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_1_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289_1_0(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute_1_1(vec4 x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nfloat permute_1_1(float x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt_1_2(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4_1_3(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise_1_4(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289_1_0(i);\n  float j0 = permute_1_1( permute_1_1( permute_1_1( permute_1_1(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute_1_1( permute_1_1( permute_1_1( permute_1_1 (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0_1_5 = grad4_1_3(j0,   ip);\n  vec4 p1 = grad4_1_3(j1.x, ip);\n  vec4 p2 = grad4_1_3(j1.y, ip);\n  vec4 p3 = grad4_1_3(j1.z, ip);\n  vec4 p4 = grad4_1_3(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt_1_2(vec4(dot(p0_1_5,p0_1_5), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_5 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt_1_2(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0_1_5, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_3_6(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_3_6(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_3_7(vec4 x)\n{\n  return mod289_3_6(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_3_8(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_3_9(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_3_10(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_3_6(Pi0);\n  Pi1 = mod289_3_6(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_3_7(permute_3_7(ix) + iy);\n  vec4 ixy0 = permute_3_7(ixy + iz0);\n  vec4 ixy1 = permute_3_7(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_3_8(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_3_8(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_3_9(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_2_11(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_12(vec4 x)\n{\n  return mod289_2_11(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_13(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade_2_14(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_2_15(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289_2_11(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute_2_12(permute_2_12(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy_2_16 = abs(gx) - 0.5 ;\n  vec4 tx_2_17 = floor(gx + 0.5);\n  gx = gx - tx_2_17;\n\n  vec2 g00 = vec2(gx.x,gy_2_16.x);\n  vec2 g10 = vec2(gx.y,gy_2_16.y);\n  vec2 g01 = vec2(gx.z,gy_2_16.z);\n  vec2 g11 = vec2(gx.w,gy_2_16.w);\n\n  vec4 norm = taylorInvSqrt_2_13(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade_2_14(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\n\nvec3 hsv2rgb_4_18(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nhighp float random_5_19(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\n\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nuniform float time;\nuniform float resolution;\nuniform float aspect;\nuniform float seed;\nuniform float flowRate;\nuniform float noiseMag;\nuniform float res1;\nuniform float res2;\nuniform sampler2D posTexture;\nuniform sampler2D velTexture;\n\n#define PI 3.141592\n#define TAU 2.*PI\n\nfloat perlin4d(vec4 pos) {\n\tfloat n = snoise_1_4(vec4(pos));\n\t// return (n + 1.0) * 0.5;\n\t// n = pow(n, 2.0);\n\t// return sin(n*5.0);\n\treturn n;\n}\n\nfloat perlin3d(vec3 pos) {\n\tfloat n = cnoise_3_10(vec3(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat perlin2d(vec2 pos) {\n\tfloat n = cnoise_2_15(vec2(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat rand(vec2 co){\n\n\t\tfloat r = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\tr = (r - 0.5) * 2.0;\n    return r;\n}\n\nfloat noise(float x, float y, float z) {\n\t// float n = perlin4d(vec4(x,y,z, time*1.0));\n\t// n = (n+1.0) * 0.5;\n\n\n\tfloat n = 0.0;\n\n\tfloat oct1 = perlin4d(vec4(x,y,z, time*0.2));\n\toct1 = (oct1+1.0) * 0.5;\n\t// oct1 *= 0.9;\n\tn += oct1;\n\n\t// vec3 subV = vec3(x,y,z) * 10.0;\n\t// float oct2 = perlin4d(vec4(subV, time*1.0));\n\t// oct2 = (oct2+1.0) * 0.5;\n\t// oct2 *= 0.1;\n\t// n += oct2;\n\n\n\treturn n;\n}\n\nvec3 curlNoise(float x, float y, float z, float eps) {\n\n\t// float eps = 0.5;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tvec3 curl = vec3(0.0);\n\n\tn1\t=\tnoise(x,\ty\t+\teps,\tz);\n\tn2\t=\tnoise(x,\ty\t-\teps,\tz);\n\ta\t=\t(n1\t-\tn2)/(2.0\t*\teps);\n\n\tn1\t=\tnoise(x,\ty,\tz\t+\teps);\n\tn2\t=\tnoise(x,\ty,\tz\t-\teps);\n\tb\t=\t(n1\t-\tn2)/(2.0\t*\teps);\n\n\tcurl.x\t=\ta\t-\tb;\n\n\tn1\t=\tnoise(x,\ty,\tz\t+\teps);\n\tn2\t=\tnoise(x,\ty,\tz\t-\teps);\n\ta\t=\t(n1\t-\tn2)/(2.0\t*\teps);\n\n\tn1\t=\tnoise(x\t+\teps,\ty,\tz);\n\tn2\t=\tnoise(x\t+\teps,\ty,\tz);\n\tb\t=\t(n1\t-\tn2)/(2.0\t*\teps);\n\n\tcurl.y\t=\ta\t-\tb;\n\tn1\t=\tnoise(x\t+\teps,\ty,\tz);\n\tn2\t=\tnoise(x\t-\teps,\ty,\tz);\n\ta\t=\t(n1\t-\tn2)/(2.0\t*\teps);\n\n\tn1\t=\tnoise(x,\ty\t+\teps,\tz);\n\tn2\t=\tnoise(x,\ty\t-\teps,\tz);\n\tb\t=\t(n1\t-\tn2)/(2.0\t*\teps);\n\n\tcurl.z\t=\ta\t-\tb;\n\n\treturn\tcurl;\n\n}\n\nvoid main() {\n\n\tvec2 pos = vUv;\n\tvec2 absPos = (gl_FragCoord.xy / resolution) - 0.5;\n\tabsPos.x *= aspect;\n\n\n\tvec3 currentPos = texture2D(posTexture, pos).xyz;\n\tvec3 currentVel = texture2D(velTexture, pos).xyz;\n\tvec3 newVel = currentVel;\n\n\n\t// check respawn\n\tvec3 newPos = currentPos;\n\tfloat spawnX = rand(absPos*100.0+time) * aspect * 0.5;\n\tfloat spawnY = -0.5 + abs(rand(absPos*200.0+time)) * 0.1;\n\t// spawnY = -0.5;\n\tvec3 spawnPos = vec3(spawnX, spawnY, 0.0);\n\tfloat dist = distance(newPos.y, spawnPos.y);\n\tif (dist > 1.0) {\n\t\tvec3 diff =  spawnPos - newPos;\n\t\tnewVel = diff;\n\t}\n\telse {\n\t\t// damp old Velocity\n\t\tnewVel *= 0.0;\n\n\t\tfloat gravity = 0.004 * flowRate;\n\n\t\tfloat mod1 = 0.01 * noiseMag;\n\t\tnewVel.x += perlin4d( vec4(currentPos, time+86.345+seed) * res1) * mod1;\n\t\tnewVel.y += perlin4d( vec4(currentPos, 15.983+time+seed) * res1) * mod1;\n\t\tnewVel.y += gravity;\n\t\tnewVel.z += perlin4d( vec4(currentPos, 41.471+time+seed) * res1) * mod1;\n\n\t\tfloat mod2 = 0.005 * noiseMag;\n\t\tnewVel.x += perlin4d( vec4(currentPos, time+86.345+seed) * res2) * mod2;\n\t\tnewVel.y += perlin4d( vec4(currentPos, 15.983+time+seed) * res2) * mod2;\n\t\tnewVel.y += gravity;\n\t\tnewVel.z += perlin4d( vec4(currentPos, 41.471+time+seed) * res2) * mod2;\n\n\n\t\t////////////////////////////\n\n\t\t// float mod2 = 0.01 * noiseMag;\n\t\t//\n\t\t// float eps = 0.5;\n\t\t// vec3 curl = curlNoise(currentPos.x*res1, currentPos.y*res1, currentPos.z*res1, eps);\n\t\t//\n\t\t// newVel.x += curl.x * mod2;\n\t\t// newVel.y += curl.y * mod2 + gravity;\n\t\t// newVel.z += curl.z * mod2;\n\t\t//\n\t\t// // float eps = 0.9;\n\t\t// curl = curlNoise(currentPos.x*res2, currentPos.y*res2, currentPos.z*res2, eps);\n\t\t//\n\t\t// mod2 = 0.005 * noiseMag;\n\t\t// newVel.x += curl.x * mod2;\n\t\t// newVel.y += curl.y * mod2 + gravity;\n\t\t// newVel.z += curl.z * mod2;\n\n\t\t///////////////////////////////\n\t}\n\n\n\tgl_FragColor = vec4(newVel, 1.0);\n}\n'},function(n,e){n.exports="\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"},function(n,e){n.exports='//\n// GLSL textureless classic 4D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_1_0(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_1(vec4 x)\n{\n  return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 fade_1_3(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_1_4(vec4 P)\n{\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod289_1_0(Pi0);\n  Pi1 = mod289_1_0(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute_1_1(permute_1_1(ix) + iy);\n  vec4 ixy0 = permute_1_1(ixy + iz0);\n  vec4 ixy1 = permute_1_1(ixy + iz1);\n  vec4 ixy00 = permute_1_1(ixy0 + iw0);\n  vec4 ixy01 = permute_1_1(ixy0 + iw1);\n  vec4 ixy10 = permute_1_1(ixy1 + iw0);\n  vec4 ixy11 = permute_1_1(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt_1_2(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt_1_2(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt_1_2(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt_1_2(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade_1_3(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\n\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_3_5(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_3_5(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_3_6(vec4 x)\n{\n  return mod289_3_5(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_3_7(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_3_8(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_3_9(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_3_5(Pi0);\n  Pi1 = mod289_3_5(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_3_6(permute_3_6(ix) + iy);\n  vec4 ixy0 = permute_3_6(ixy + iz0);\n  vec4 ixy1 = permute_3_6(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_3_7(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_3_7(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_3_8(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_2_10(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_11(vec4 x)\n{\n  return mod289_2_10(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_12(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade_2_13(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_2_14(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289_2_10(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute_2_11(permute_2_11(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy_2_15 = abs(gx) - 0.5 ;\n  vec4 tx_2_16 = floor(gx + 0.5);\n  gx = gx - tx_2_16;\n\n  vec2 g00 = vec2(gx.x,gy_2_15.x);\n  vec2 g10 = vec2(gx.y,gy_2_15.y);\n  vec2 g01 = vec2(gx.z,gy_2_15.z);\n  vec2 g11 = vec2(gx.w,gy_2_15.w);\n\n  vec4 norm = taylorInvSqrt_2_12(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade_2_13(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\n\nvec3 hsv2rgb_4_17(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nhighp float random_5_18(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\n\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nuniform float time;\nuniform float resolution;\nuniform float aspect;\nuniform float seed;\nuniform float flowRate;\nuniform float respawn;\nuniform float res1;\nuniform float res2;\nuniform sampler2D posTexture;\nuniform sampler2D velTexture;\n\nfloat perlin4d(vec4 pos) {\n\tfloat n = cnoise_1_4(vec4(pos));\n\t// return (n + 1.0) * 0.5;\n\t// n = pow(n, 2.0);\n\t// return sin(n*5.0);\n\treturn n;\n}\n\nfloat perlin3d(vec3 pos) {\n\tfloat n = cnoise_3_9(vec3(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat perlin2d(vec2 pos) {\n\tfloat n = cnoise_2_14(vec2(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat rand(vec2 co){\n\n\t\tfloat r = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\tr = (r - 0.5) * 2.0;\n    return r;\n}\n\nvoid main() {\n\n\tvec2 pos = vUv;\n\tvec2 absPos = (gl_FragCoord.xy / resolution) - 0.5;\n\tabsPos.x *= aspect;\n\n\n\tvec3 currentPos = texture2D(posTexture, pos).xyz;\n\tvec3 currentVel = texture2D(velTexture, pos).xyz;\n\tvec3 newVel = currentVel;\n\n\t// check respawn distancee\n\tvec3 newPos = currentPos;\n\tvec3 orgPos = vec3(absPos, 0.0);\n\tfloat dist = distance(newPos, orgPos);\n\tif (dist > respawn) {\n\t\tvec3 diff =  orgPos - newPos;\n\t\tnewVel = diff;\n\t}\n\telse {\n\t\t// damp old Velocity\n\t\tfloat damp = 0.0;\n\t\tnewVel *= damp;\n\t\tfloat dampMod = 1.0 - damp;\n\n\n\t\tfloat mod1 = 0.015 * flowRate * dampMod;\n\t\tnewVel.x += perlin4d( vec4(currentPos, time+86.345+seed) * res1) * mod1;\n\t\tnewVel.y += perlin4d( vec4(currentPos, 15.983+time+seed) * res1) * mod1;\n\t\tnewVel.z += perlin4d( vec4(currentPos, 41.471+time+seed) * res1) * mod1;\n\n\t\tfloat mod2 = 0.003 * flowRate * dampMod;\n\t\tnewVel.x += perlin4d( vec4(currentPos, time+86.345+seed) * res2) * mod2;\n\t\tnewVel.y += perlin4d( vec4(currentPos, 15.983+time+seed) * res2) * mod2;\n\t\tnewVel.z += perlin4d( vec4(currentPos, 41.471+time+seed) * res2) * mod2;\n\n\t\t// float mod3 = 0.0002 * flowRate;\n\t\t// newVel.x += rand(absPos+98.24+time) * mod3 * 0.333;\n\t\t// newVel.y += rand(absPos+43.357+time) * mod3;\n\t\t// newVel.z += rand(absPos+34.972+time) * mod3;\n\t}\n\n\n\tgl_FragColor = vec4(newVel, 1.0);\n}\n'},function(n,e){n.exports="\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"},function(n,e){n.exports="//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_1_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289_1_0(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute_1_1(vec4 x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nfloat permute_1_1(float x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt_1_2(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4_1_3(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise_1_4(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289_1_0(i);\n  float j0 = permute_1_1( permute_1_1( permute_1_1( permute_1_1(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute_1_1( permute_1_1( permute_1_1( permute_1_1 (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0_1_5 = grad4_1_3(j0,   ip);\n  vec4 p1 = grad4_1_3(j1.x, ip);\n  vec4 p2 = grad4_1_3(j1.y, ip);\n  vec4 p3 = grad4_1_3(j1.z, ip);\n  vec4 p4 = grad4_1_3(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt_1_2(vec4(dot(p0_1_5,p0_1_5), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_5 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt_1_2(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0_1_5, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2_6(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2_6(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_7(vec4 x) {\n     return mod289_2_6(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_8(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_2_9(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_2_10 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_2_11 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_2_11;\n  vec3 i1 = min( g_2_11.xyz, l.zxy );\n  vec3 i2 = max( g_2_11.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_2_10.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_2_6(i);\n  vec4 p = permute_2_7( permute_2_7( permute_2_7(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_2_10.wyz - D_2_10.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_2_12 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_2_13 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_2_12.xy,h.z);\n  vec3 p3 = vec3(a1_2_12.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_2_8(vec4(dot(p0_2_13,p0_2_13), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_2_13 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_2_13,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_3_14(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_3_14(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_3_15(vec3 x) {\n  return mod289_3_14(((x*34.0)+1.0)*x);\n}\n\nfloat snoise_3_16(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_3_14(i); // Avoid truncation effects in permutation\n  vec3 p = permute_3_15( permute_3_15( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n\nvec3 hsv2rgb_4_17(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nhighp float random_5_18(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\n\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nuniform float time;\nuniform float resolution;\nuniform float aspect;\nuniform float seed;\nuniform float noiseMag;\nuniform float noiseRes;\nuniform float tNoise;\nuniform sampler2D posTexture;\nuniform sampler2D velTexture;\n\nfloat perlin4d(vec4 pos) {\n\tfloat n = snoise_1_4(vec4(pos));\n\t// return (n + 1.0) * 0.5;\n\t// n = pow(n, 2.0);\n\t// return sin(n*5.0);\n\treturn n;\n}\n\nfloat perlin3d(vec3 pos) {\n\tfloat n = snoise_2_9(vec3(pos));\n\t// return (n + 1.0) * 0.5;\n\t// n = abs(n);\n\t// n = n - 0.25;\n\t// n = (n-0.5) * 2.0;\n\treturn n;\n}\n\nfloat perlin2d(vec2 pos) {\n\tfloat n = snoise_3_16(vec2(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat rand(vec2 co){\n\n\t\tfloat r = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\tr = (r - 0.5) * 2.0;\n    return r;\n}\n\nfloat fbm(vec3 pos, float res) {\n\tfloat n = 0.0;\n\tfloat amp = 0.5;\n\tfloat frq = res;\n\n\tfor (int i=0; i<8; i++) {\n\t\tn += perlin3d(pos * frq) * amp;\n\t\tfrq *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\n\treturn n;\n}\n\nvoid main() {\n\n\tvec2 pos = vUv;\n\tvec2 absPos = (gl_FragCoord.xy / resolution) - 0.5;\n\tabsPos.x *= aspect;\n\n\n\tvec3 currentPos = texture2D(posTexture, pos).xyz;\n\tvec3 currentVel = texture2D(velTexture, pos).xyz;\n\tvec3 newVel = currentVel;\n\n\tnewVel *= 0.0;\n\tvec3 newPos = vec3(absPos, 0.0);\n\tvec3 offset = vec3(0.0);\n\n\n\toffset.x += fbm(vec3(absPos, tNoise+seed+86.345), noiseRes) * noiseMag;\n\toffset.y += fbm(vec3(absPos, tNoise+seed+31.946), noiseRes) * noiseMag;\n\n\toffset.z = offset.x + offset.y;\n\n\n\tnewPos += offset;\n\tnewPos *= 1.0 + noiseMag;\n\tnewVel = (newPos - currentPos) * 0.1;\n\n\n\tgl_FragColor = vec4(newVel, 1.0);\n}\n"},function(n,e){n.exports="\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"},function(n,e){n.exports='//\n// GLSL textureless classic 4D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_1_0(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_1(vec4 x)\n{\n  return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 fade_1_3(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_1_4(vec4 P)\n{\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod289_1_0(Pi0);\n  Pi1 = mod289_1_0(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute_1_1(permute_1_1(ix) + iy);\n  vec4 ixy0 = permute_1_1(ixy + iz0);\n  vec4 ixy1 = permute_1_1(ixy + iz1);\n  vec4 ixy00 = permute_1_1(ixy0 + iw0);\n  vec4 ixy01 = permute_1_1(ixy0 + iw1);\n  vec4 ixy10 = permute_1_1(ixy1 + iw0);\n  vec4 ixy11 = permute_1_1(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt_1_2(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt_1_2(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt_1_2(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt_1_2(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade_1_3(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\n\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_3_5(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_3_5(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_3_6(vec4 x)\n{\n  return mod289_3_5(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_3_7(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_3_8(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_3_9(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_3_5(Pi0);\n  Pi1 = mod289_3_5(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_3_6(permute_3_6(ix) + iy);\n  vec4 ixy0 = permute_3_6(ixy + iz0);\n  vec4 ixy1 = permute_3_6(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_3_7(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_3_7(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_3_8(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_2_10(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_11(vec4 x)\n{\n  return mod289_2_10(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_12(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade_2_13(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_2_14(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289_2_10(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute_2_11(permute_2_11(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy_2_15 = abs(gx) - 0.5 ;\n  vec4 tx_2_16 = floor(gx + 0.5);\n  gx = gx - tx_2_16;\n\n  vec2 g00 = vec2(gx.x,gy_2_15.x);\n  vec2 g10 = vec2(gx.y,gy_2_15.y);\n  vec2 g01 = vec2(gx.z,gy_2_15.z);\n  vec2 g11 = vec2(gx.w,gy_2_15.w);\n\n  vec4 norm = taylorInvSqrt_2_12(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade_2_13(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\n\nvec3 hsv2rgb_4_17(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nhighp float random_5_18(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\n\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nuniform float time;\nuniform float resolution;\nuniform float aspect;\nuniform float seed;\nuniform float flowRate;\nuniform float res1;\nuniform float res2;\nuniform sampler2D posTexture;\nuniform sampler2D velTexture;\n\nfloat perlin4d(vec4 pos) {\n\tfloat n = cnoise_1_4(vec4(pos));\n\t// return (n + 1.0) * 0.5;\n\t// n = pow(n, 2.0);\n\t// return sin(n*5.0);\n\treturn n;\n}\n\nfloat perlin3d(vec3 pos) {\n\tfloat n = cnoise_3_9(vec3(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat perlin2d(vec2 pos) {\n\tfloat n = cnoise_2_14(vec2(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat rand(vec2 co){\n\n\t\tfloat r = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\tr = (r - 0.5) * 2.0;\n    return r;\n}\n\nvoid main() {\n\n\tvec2 pos = vUv;\n\tvec2 absPos = (gl_FragCoord.xy / resolution) - 0.5;\n\tabsPos.x *= aspect;\n\n\n\tvec3 currentPos = texture2D(posTexture, pos).xyz;\n\tvec3 currentVel = texture2D(velTexture, pos).xyz;\n\tvec3 newVel = currentVel;\n\n\tnewVel *= 0.0;\n\tvec3 newPos = vec3(absPos, 0.0);\n\n\tvec3 offset = vec3(0.0);\n\tfloat modx, mody;\n\n\n\tmody = sin(time * 0.7 + 20.347);\n\tmodx = sin(time * 0.9 + 37.237);\n\toffset.y = sin(time + (absPos.x+0.268)*10.0 * mody) * 0.1;\n\toffset.x = sin(time + (absPos.y-0.926)*25.0 * modx) * 0.1;\n\n\tmody = sin(time * 0.83 + 51.647);\n\tmodx = sin(time * 0.74 + 13.837);\n\toffset.y += sin(time + (absPos.x-0.348)*22.0 * mody) * 0.05;\n\toffset.x += sin(time + (absPos.y+1.253)*47.0 * modx) * 0.05;\n\n\tmody = sin(time * 0.8 + 49.387);\n\tmodx = sin(time * 0.6 + 90.479);\n\toffset.y += sin(time + (absPos.x+0.743)*50.0 * mody) * 0.02;\n\toffset.x += sin(time + (absPos.y-0.683)*70.0 * modx) * 0.02;\n\n\tmody = sin(time * 0.87 + 38.587);\n\tmodx = sin(time * 0.66 + 52.879);\n\toffset.y += sin(time + (absPos.x-0.427)*10.0 * mody) * 0.01;\n\toffset.x += sin(time + (absPos.y+0.539)*20.0 * modx) * 0.01;\n\n\toffset.z = offset.x + offset.y;\n\n\tnewPos += offset;\n\tnewVel = (newPos - currentPos) * 0.1;\n\n\n\tgl_FragColor = vec4(newVel, 1.0);\n}\n'},function(n,e){n.exports="\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"},function(n,e){n.exports='//\n// GLSL textureless classic 4D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_1_0(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_1(vec4 x)\n{\n  return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 fade_1_3(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_1_4(vec4 P)\n{\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod289_1_0(Pi0);\n  Pi1 = mod289_1_0(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute_1_1(permute_1_1(ix) + iy);\n  vec4 ixy0 = permute_1_1(ixy + iz0);\n  vec4 ixy1 = permute_1_1(ixy + iz1);\n  vec4 ixy00 = permute_1_1(ixy0 + iw0);\n  vec4 ixy01 = permute_1_1(ixy0 + iw1);\n  vec4 ixy10 = permute_1_1(ixy1 + iw0);\n  vec4 ixy11 = permute_1_1(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt_1_2(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt_1_2(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt_1_2(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt_1_2(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade_1_3(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\n\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_3_5(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_3_5(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_3_6(vec4 x)\n{\n  return mod289_3_5(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_3_7(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_3_8(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_3_9(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_3_5(Pi0);\n  Pi1 = mod289_3_5(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_3_6(permute_3_6(ix) + iy);\n  vec4 ixy0 = permute_3_6(ixy + iz0);\n  vec4 ixy1 = permute_3_6(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_3_7(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_3_7(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_3_8(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_2_10(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_11(vec4 x)\n{\n  return mod289_2_10(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_12(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade_2_13(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_2_14(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289_2_10(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute_2_11(permute_2_11(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy_2_15 = abs(gx) - 0.5 ;\n  vec4 tx_2_16 = floor(gx + 0.5);\n  gx = gx - tx_2_16;\n\n  vec2 g00 = vec2(gx.x,gy_2_15.x);\n  vec2 g10 = vec2(gx.y,gy_2_15.y);\n  vec2 g01 = vec2(gx.z,gy_2_15.z);\n  vec2 g11 = vec2(gx.w,gy_2_15.w);\n\n  vec4 norm = taylorInvSqrt_2_12(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade_2_13(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\n\nvec3 hsv2rgb_4_17(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nhighp float random_5_18(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\n\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nuniform float time;\nuniform float resolution;\nuniform float aspect;\nuniform float seed;\nuniform float flowRate;\nuniform float res1;\nuniform float res2;\nuniform float curveMag;\nuniform float curveMod;\nuniform float pulseMag;\nuniform sampler2D posTexture;\nuniform sampler2D velTexture;\n\n#define PI 3.141592\n#define TAU 2.*PI\n\nfloat perlin4d(vec4 pos) {\n\tfloat n = cnoise_1_4(vec4(pos));\n\t// return (n + 1.0) * 0.5;\n\t// n = pow(n, 2.0);\n\t// return sin(n*5.0);\n\treturn n;\n}\n\nfloat perlin3d(vec3 pos) {\n\tfloat n = cnoise_3_9(vec3(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat perlin2d(vec2 pos) {\n\tfloat n = cnoise_2_14(vec2(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat rand(vec2 co){\n\n\t\tfloat r = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\tr = (r - 0.5) * 2.0;\n    return r;\n}\n\nvoid main() {\n\n\tvec2 pos = vUv;\n\tvec2 absPos = (gl_FragCoord.xy / resolution) - 0.5;\n\tabsPos.x *= aspect;\n\n\tvec3 currentPos = texture2D(posTexture, pos).xyz;\n\n\tvec3 currentVel = texture2D(velTexture, pos).xyz;\n\tvec3 newVel = currentVel;\n\n\tnewVel *= 0.0;\n\tvec3 newPos = vec3(absPos, 0.0);\n\n\tvec3 offset = vec3(0.0);\n\n\tvec3 dir = normalize(vec3(absPos, 0.0));\n\tfloat dist = length(absPos);\n\tfloat angle = atan(dir.x, dir.y);\n\t// angle = fract(angle*2.0);\n\n\tfloat osc = sin(time * 0.5 + dist*5.0) * curveMod;\n\tosc = 1.0;\n\tfloat mod1 = sin(-time + angle*res1) * 0.4 * curveMag * osc;\n\n\tfloat mod2 = sin(-time + angle*res2) * 0.4 * curveMag * osc;\n\t// float mod3 = sin(-time + angle*13.0) * 0.025 * curveMag;\n\n\tfloat mod4 = sin(-time+dist*30.1) * 0.1 * pulseMag;\n\tfloat mod5 = sin(-time+dist*50.1) * 0.1 * pulseMag;\n\n\toffset += dir * (mod1+mod2+mod4+mod5);\n\n\t///////////////////////////////\n\n\toffset.z = offset.x + offset.y;\n\n\tnewPos += offset;\n\n\t// newPos.xy *= 5.0;\n\t// newPos.xy = fract(newPos.xy);\n\t//\n\t// currentPos.xy *= 5.0;\n\t// currentPos.xy = fract(currentPos.xy);\n\n\tnewVel = (newPos - currentPos) * 0.1;\n\n\n\tgl_FragColor = vec4(newVel, 1.0);\n}\n'},function(n,e){n.exports="\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"},function(n,e){n.exports='//\n// GLSL textureless classic 4D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_1_0(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_1(vec4 x)\n{\n  return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 fade_1_3(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_1_4(vec4 P)\n{\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod289_1_0(Pi0);\n  Pi1 = mod289_1_0(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute_1_1(permute_1_1(ix) + iy);\n  vec4 ixy0 = permute_1_1(ixy + iz0);\n  vec4 ixy1 = permute_1_1(ixy + iz1);\n  vec4 ixy00 = permute_1_1(ixy0 + iw0);\n  vec4 ixy01 = permute_1_1(ixy0 + iw1);\n  vec4 ixy10 = permute_1_1(ixy1 + iw0);\n  vec4 ixy11 = permute_1_1(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt_1_2(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt_1_2(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt_1_2(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt_1_2(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade_1_3(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\n\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2_5(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_2_5(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_6(vec4 x)\n{\n  return mod289_2_5(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_7(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_2_8(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_2_9(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_2_5(Pi0);\n  Pi1 = mod289_2_5(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_2_6(permute_2_6(ix) + iy);\n  vec4 ixy0 = permute_2_6(ixy + iz0);\n  vec4 ixy1 = permute_2_6(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_2_7(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_2_7(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_2_8(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_3_10(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_3_11(vec4 x)\n{\n  return mod289_3_10(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_3_12(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade_3_13(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_3_14(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289_3_10(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute_3_11(permute_3_11(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy_3_15 = abs(gx) - 0.5 ;\n  vec4 tx_3_16 = floor(gx + 0.5);\n  gx = gx - tx_3_16;\n\n  vec2 g00 = vec2(gx.x,gy_3_15.x);\n  vec2 g10 = vec2(gx.y,gy_3_15.y);\n  vec2 g01 = vec2(gx.z,gy_3_15.z);\n  vec2 g11 = vec2(gx.w,gy_3_15.w);\n\n  vec4 norm = taylorInvSqrt_3_12(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade_3_13(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\n\nvec3 hsv2rgb_5_17(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nhighp float random_4_18(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\n\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nuniform float time;\nuniform float resolution;\nuniform float aspect;\nuniform float seed;\nuniform float flowRate;\nuniform float res1;\nuniform float res2;\nuniform sampler2D posTexture;\nuniform sampler2D velTexture;\n\n#define PI 3.141592\n#define TAU 2.*PI\n\nfloat perlin4d(vec4 pos) {\n\tfloat n = cnoise_1_4(vec4(pos));\n\t// return (n + 1.0) * 0.5;\n\t// n = pow(n, 2.0);\n\t// return sin(n*5.0);\n\treturn n;\n}\n\nfloat perlin3d(vec3 pos) {\n\tfloat n = cnoise_2_9(vec3(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat perlin2d(vec2 pos) {\n\tfloat n = cnoise_3_14(vec2(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat rand(vec2 co){\n\n\t\tfloat r = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\tr = (r - 0.5) * 2.0;\n    return r;\n}\n\nvoid main() {\n\n\tvec2 pos = vUv;\n\tvec2 absPos = (gl_FragCoord.xy / resolution) - 0.5;\n\tabsPos.x *= aspect;\n\n\tvec3 currentPos = texture2D(posTexture, pos).xyz;\n\tvec3 currentVel = texture2D(velTexture, pos).xyz;\n\tvec3 newVel = currentVel;\n\n\tnewVel *= 0.0;\n\tvec3 newPos = vec3(absPos, 0.0);\n\n\tvec3 offset = vec3(0.0);\n\n\t/////////////////////////////\n\n\tvec3 dir = normalize(vec3(absPos, 0.0));\n\tfloat dist = length(absPos);\n\n\t// large waves\n\toffset.y += sin(time*0.5 + absPos.x*6.0) * 0.1;\n\toffset.y += sin(time*0.5 + absPos.x*10.0) * 0.1;\n\n\t// folds\n\tfloat osc = sin(time*0.3 + absPos.y*3.0) * 0.3;\n\tfloat subOsc = cos(time*0.4 + absPos.x*4.0) * 17.0;\n\tosc += sin(time*0.6 + absPos.y*subOsc) * 0.3;\n\toffset.x += sin(time*4.3 + absPos.x*25.0) * absPos.y * osc;\n\n\t// stripe ripples\n\tosc = sin(time*0.05 + absPos.y*9.0) * 60.0;\n\toffset.y += sin(time*1.0 + absPos.y*osc) * 0.01;\n\tosc = sin(time*0.03 + absPos.y*5.0) * 200.0;\n\toffset.y += sin(time*3.0 + absPos.y*osc) * 0.01;\n\n\t/////////////////////////////\n\n\toffset.z = offset.x + offset.y;\n\n\tnewPos += offset;\n\tnewVel = (newPos - currentPos) * 0.1;\n\n\t// newVel = offset * 0.01;\n\n\tgl_FragColor = vec4(newVel, 1.0);\n}\n'},function(n,e){n.exports="\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"},function(n,e){n.exports='//\n// GLSL textureless classic 4D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_3_0(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_3_1(vec4 x)\n{\n  return mod289_3_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_3_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 fade_3_3(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_3_4(vec4 P)\n{\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod289_3_0(Pi0);\n  Pi1 = mod289_3_0(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute_3_1(permute_3_1(ix) + iy);\n  vec4 ixy0 = permute_3_1(ixy + iz0);\n  vec4 ixy1 = permute_3_1(ixy + iz1);\n  vec4 ixy00 = permute_3_1(ixy0 + iw0);\n  vec4 ixy01 = permute_3_1(ixy0 + iw1);\n  vec4 ixy10 = permute_3_1(ixy1 + iw0);\n  vec4 ixy11 = permute_3_1(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt_3_2(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt_3_2(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt_3_2(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt_3_2(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade_3_3(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\n\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1_5(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1_5(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_6(vec4 x)\n{\n  return mod289_1_5(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_7(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_1_8(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_1_9(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1_5(Pi0);\n  Pi1 = mod289_1_5(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1_6(permute_1_6(ix) + iy);\n  vec4 ixy0 = permute_1_6(ixy + iz0);\n  vec4 ixy1 = permute_1_6(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1_7(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1_7(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_1_8(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_2_10(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_11(vec4 x)\n{\n  return mod289_2_10(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_12(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade_2_13(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_2_14(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289_2_10(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute_2_11(permute_2_11(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy_2_15 = abs(gx) - 0.5 ;\n  vec4 tx_2_16 = floor(gx + 0.5);\n  gx = gx - tx_2_16;\n\n  vec2 g00 = vec2(gx.x,gy_2_15.x);\n  vec2 g10 = vec2(gx.y,gy_2_15.y);\n  vec2 g01 = vec2(gx.z,gy_2_15.z);\n  vec2 g11 = vec2(gx.w,gy_2_15.w);\n\n  vec4 norm = taylorInvSqrt_2_12(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade_2_13(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\n\nvec3 hsv2rgb_5_17(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nhighp float random_4_18(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\n\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nuniform float time;\nuniform float resolution;\nuniform float aspect;\nuniform float seed;\nuniform float flowRate;\nuniform float res1;\nuniform float res2;\nuniform float sizeMod;\nuniform sampler2D posTexture;\nuniform sampler2D velTexture;\n\n#define PI 3.141592\n#define TAU 2.*PI\n\nfloat perlin4d(vec4 pos) {\n\tfloat n = cnoise_3_4(vec4(pos));\n\t// return (n + 1.0) * 0.5;\n\t// n = pow(n, 2.0);\n\t// return sin(n*5.0);\n\treturn n;\n}\n\nfloat perlin3d(vec3 pos) {\n\tfloat n = cnoise_1_9(vec3(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat perlin2d(vec2 pos) {\n\tfloat n = cnoise_2_14(vec2(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat rand(vec2 co){\n\n\t\tfloat r = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\tr = (r - 0.5) * 2.0;\n    return r;\n}\n\nvoid main() {\n\n\tvec2 pos = vUv;\n\tvec2 absPos = (gl_FragCoord.xy / resolution) - 0.5;\n\tabsPos.x *= aspect;\n\n\tvec3 currentPos = texture2D(posTexture, pos).xyz;\n\tvec3 currentVel = texture2D(velTexture, pos).xyz;\n\tvec3 newVel = currentVel;\n\n\tnewVel *= 0.0;\n\n\t/////////////////////////////\n\n\tvec3 targetPos = vec3(0.0);\n\tfloat offset;\n\tfloat size;\n\tfloat numStripes;\n\n\t// osc 1\n\n\toffset = rand(absPos);\n\toffset = floor(offset * 30.0) / 30.0;\n\toffset *= TAU;\n\n\n\tsize = 0.5;\n\ttargetPos.y += sin(time+offset) * size * sizeMod;\n\ttargetPos.x += cos(time+offset) * size * sizeMod;\n\ttargetPos.z += cos(time+offset) * size * sizeMod;\n\n\t// osc2\n\tnumStripes = sin(time*0.3 + 25.0);\n\tnumStripes = (numStripes*0.5) + 0.5;\n\tnumStripes = (numStripes * 10.0) + 2.0;\n\n\toffset = rand(absPos+40.0);\n\toffset = floor(offset * numStripes) / numStripes;\n\toffset *= TAU;\n\n\n\tsize = sin(time*0.7 + 72.9) * 0.5 + 0.5;\n\tsize = 0.2 + size*0.5;\n\ttargetPos.y += sin(time*0.1 + offset) * size * sizeMod;\n\ttargetPos.x += cos(time*0.1 + offset) * size * sizeMod;\n\ttargetPos.z += cos(time*0.2 + offset) * size * sizeMod;\n\n\n\n\t// circles\n\n\tfloat angle = rand(absPos + 13.0) * TAU;\n\tfloat radius = 0.01;\n\t// float radius = 0.05 * rand((absPos*1000.0)+time*0.0001);\n\n\ttargetPos.y += sin(angle) * radius;\n\ttargetPos.x += cos(angle) * radius;\n\ttargetPos.z += cos(angle) * radius;\n\n\n\t/////////////////////////////\n\n\n\tnewVel = (targetPos - currentPos) * 0.01;\n\n\tgl_FragColor = vec4(newVel, 1.0);\n}\n'},function(n,e){n.exports="\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"},function(n,e){n.exports='//\n// GLSL textureless classic 4D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_2_0(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_2_1(vec4 x)\n{\n  return mod289_2_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_2_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 fade_2_3(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_2_4(vec4 P)\n{\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod289_2_0(Pi0);\n  Pi1 = mod289_2_0(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute_2_1(permute_2_1(ix) + iy);\n  vec4 ixy0 = permute_2_1(ixy + iz0);\n  vec4 ixy1 = permute_2_1(ixy + iz1);\n  vec4 ixy00 = permute_2_1(ixy0 + iw0);\n  vec4 ixy01 = permute_2_1(ixy0 + iw1);\n  vec4 ixy10 = permute_2_1(ixy1 + iw0);\n  vec4 ixy11 = permute_2_1(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt_2_2(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt_2_2(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt_2_2(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt_2_2(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade_2_3(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\n\n\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_3_5(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_3_5(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_3_6(vec4 x)\n{\n  return mod289_3_5(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_3_7(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_3_8(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_3_9(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_3_5(Pi0);\n  Pi1 = mod289_3_5(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_3_6(permute_3_6(ix) + iy);\n  vec4 ixy0 = permute_3_6(ixy + iz0);\n  vec4 ixy1 = permute_3_6(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_3_7(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_3_7(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_3_8(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\n//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_1_10(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1_11(vec4 x)\n{\n  return mod289_1_10(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_12(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade_1_13(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise_1_14(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289_1_10(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute_1_11(permute_1_11(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy_1_15 = abs(gx) - 0.5 ;\n  vec4 tx_1_16 = floor(gx + 0.5);\n  gx = gx - tx_1_16;\n\n  vec2 g00 = vec2(gx.x,gy_1_15.x);\n  vec2 g10 = vec2(gx.y,gy_1_15.y);\n  vec2 g01 = vec2(gx.z,gy_1_15.z);\n  vec2 g11 = vec2(gx.w,gy_1_15.w);\n\n  vec4 norm = taylorInvSqrt_1_12(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade_1_13(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n\n\nvec3 hsv2rgb_4_17(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nhighp float random_5_18(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\n\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nuniform float time;\nuniform float resolution;\nuniform float aspect;\nuniform float seed;\nuniform float flowRate;\nuniform float res1;\nuniform float res2;\nuniform sampler2D posTexture;\nuniform sampler2D velTexture;\n\n#define PI 3.141592\n#define TAU 2.*PI\n\nfloat perlin4d(vec4 pos) {\n\tfloat n = cnoise_2_4(vec4(pos));\n\t// return (n + 1.0) * 0.5;\n\t// n = pow(n, 2.0);\n\t// return sin(n*5.0);\n\treturn n;\n}\n\nfloat perlin3d(vec3 pos) {\n\tfloat n = cnoise_3_9(vec3(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat perlin2d(vec2 pos) {\n\tfloat n = cnoise_1_14(vec2(pos));\n\t// return (n + 1.0) * 0.5;\n\treturn n;\n}\n\nfloat rand(vec2 co){\n\n\t\tfloat r = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\tr = (r - 0.5) * 2.0;\n    return r;\n}\n\nvoid main() {\n\n\tvec2 pos = vUv;\n\tvec2 absPos = (gl_FragCoord.xy / resolution) - 0.5;\n\tabsPos.x *= aspect;\n\n\n\tvec3 currentPos = texture2D(posTexture, pos).xyz;\n\tvec3 currentVel = texture2D(velTexture, pos).xyz;\n\tvec3 newVel = currentVel;\n\n\tnewVel *= 0.0;\n\tvec3 newPos = vec3(absPos, 0.0);\n\n\tvec3 offset = vec3(0.0);\n\n\t/////////////////////////////\n\n\tvec3 dir = normalize(vec3(absPos, 0.0));\n\tfloat dist = length(absPos);\n\n\tfloat mod1 = sin(-time+dist*50.1) * 0.05;\n\tfloat mod2 = sin(-time+dist*30.1) * 0.05;\n\n\toffset += dir * (mod1 + mod2);\n\n\tfloat size = 0.0;\n\tfloat strength = 0.1;\n\n\tsize = sin(time*0.05 + dist) * 10.0;\n\tstrength = sin(time*0.07 + dist*5.0) * 0.1;\n\toffset.y += sin(time*0.1 + abs(absPos.x)*size) * strength;\n\n\tsize = sin(time*0.07 + dist) * 15.0;\n\tstrength = sin(time*0.05 + dist*5.0) * 0.1;\n\toffset.y += sin(time*0.07 + abs(absPos.x)*size) * strength;\n\n\tsize = sin(time*0.03 + dist) * 22.0;\n\tstrength = sin(time*0.09 + dist*5.0) * 0.1;\n\toffset.y += sin(time*0.04 + abs(absPos.x)*size) * strength;\n\n\t/////////////////////////////\n\n\toffset.z = offset.x + offset.y;\n\n\tnewPos += offset;\n\tnewVel = (newPos - currentPos) * 0.1;\n\n\n\tgl_FragColor = vec4(newVel, 1.0);\n}\n'},function(n,e){n.exports="\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"}],[11]);